#include <iostream>
#include <complex>
using namespace std;

#define FASTIO ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL); // boj_15552.cpp
#define SETPRECISION(n) cout << fixed;cout.precision(n); // boj_1008.cpp
#define SIZE(v) (int)v.size()
#define ALL(v) v.begin(),v.end()
using ll = long long;
using uint = unsigned int;
using ull = unsigned long long;
using cpx = complex<double>;

int main() {
    FASTIO;

    // 내용 출처 : http://seismic.yonsei.ac.kr/complex.html

    // complex 타입의 객체를 선언하기 위해서는 먼저 복소수의 실수부와 허수부의 타입을 무엇으로 할지를 결정해야 한다.
    // 복소수의 실수부와 허수부의 타입은 템플릿 인자로 넘겨주며, 이때 인자의 타입은 C++에서 제공하는 부동소수 데이터 타입만이 허용된다. (즉, float, double, long double 세 가지만 가능하다.)



    // complex 클래스는 네 가지 형태의 생성자를 가지고 있다.
    cpx cpx1; // 0 + 0i
    cpx cpx2(3.14); // 3.14 + 0i
    cpx cpx3(1.1, 2.7); // 1.1 + 2.7i
    cpx cpx4(cpx3); // 1.1 + 2.7i (cpx3와 동일)

    // 당연히 complex 객체 사이에는 서로 대입이 가능하댜. 또한 복소수 타입의 변수에 실수값을 대입할 수도 있는데, 이 경우 실수부는 해당 실수값을 가지게 되고 허수부는 0 값을 가지게 된다.
    cpx1 = cpx3; // cpx1 : 1.1 + 2.7i
    cpx3 = 2.17; // cpx3 : 2.17 + 0i

    // polar() 함수는 극형식(크기와 위상각으로 표현)에 해당하는 복소수 값을 알아내는데 사용한다.
    cpx cpx5 = polar(5.6, 1.8); // 5.6 * (cos(1.8) + sin(1.8) i)

    // conj() 함수는 인자로 주어진 복소수의 보수를 구할 때 사용한다. 주어진 복소수가 x + yi라면, 이것의 보수는 x - yi가 된다.
    cpx cpx6 = conj(cpx1); // 1.1 - 2.7i

    // 멤버함수로 제공되는 real() 함수와 imag() 함수는 각각 복소수의 실수부와 허수부를 반환한다. 이들은 멤버 함수 뿐만 아니라, 일반 함수의 형태로도 호출할 수 있다.
    cout << cpx1.real() << "+" << cpx1.imag() << "i\n";
    cout << real(cpx1) << "+" << imag(cpx1) << "i\n";

    cout << "==============================\n";



    // 복소수는 입출력 스트림을 이용한 읽기, 쓰기가 가능하다. 쉽게 말해, '<<' 연산자와 '>>' 연산자를 이용하여 복소수의 출력과 입력을 수행할 수 있다. 복소수를 출력할 때는 양쪽에 괄호를 씌워서 출력된다.
    cpx cpx7(3.0, 4.0);
    cout << cpx7 << '\n'; // (3,4)
    cpx cpx8(3.0);
    cout << cpx8 << '\n'; // (3)

    cout << "==============================\n";

    // +, -, *, / 연산자들은 각각 복소수의 덧셈, 뺄셈, 곱셈, 나눗셈을 수행하는데 사용한다. 이 연산자들은 두 복소수 간의 사칙연산을 수행하며, 복소수와 실수 간의 사칙연산에도 사용할 수 있다.
    cpx cpx9(3.0, 4.0); // 3.0 + 4.0i
    cpx cpx10(1.0, 2.0); // 1.0 + 2.0i

    cout << cpx9 + cpx10 << '\n'; // (4,6)
    cout << cpx9 - 5.0 << '\n'; // (-2,4)
    cout << cpx10 * 1.5 << '\n'; // (1.5,3)

    // +=, -=, *=, /= 연산자 또한 정의되어 있다.
    cpx9 += cpx10;
    cout << cpx9 << '\n'; // (4,6)

    // 단항 연산자 +와 -도 정의되어 있다. 단항연산자 -는 실수부와 허수부의 부호를 모두 바꿔준다.
    cout << -cpx9 << '\n'; // (-4,-6)

    // == 연산자와 != 연산자를 사용하여 복소수 사이의 상등관계를 확인할 수 있다. 두 복소수의 상등관계는 실수부와 허수부가 모두 같을 때 성립한다. 단, 복소수 사이의 대소관계는 정의되어 있지 않으므로 이에 유의해야 한다. 즉, 복소수 사이에는 <, >, <=, >=와 같은 비교 연산자를 사용할 수 없다.
    cpx cpx11(1.0, 2.0);
    cpx cpx12(1.0, 2.0);
    cpx cpx13(-1.0, 2.0);
    cout << (cpx11 == cpx12) << '\n';
    cout << (cpx11 == cpx13) << '\n';

    cout << "==============================\n";



    // norm() 함수는 복소수의 norm 값을 반환한다. norm 값은 실수부의 제곱과 허수부의 제곱의 합을 말한다.
    // abs() 함수는 복소수의 절댓값을 반환한다. 이는 norm 값의 제곱근에 해당한다.
    // 이 두 함수는 모두 멤버 함수가 아닌, 복소수를 인자로 가지는 일반 함수이다.
    cpx cpx14(3.0, 4.0);
    cout << norm(cpx14) << '\n'; // 25
    cout << abs(cpx14) << '\n'; // 5

    // arg() 함수는 복소수의 유향 위상각을 반환한다.
    cpx cpx15 = polar(5.6, 1.8); // 5.6 * (cos(1.8) + sin(1.8) i)
    cout << arg(cpx15) << '\n'; // 1.8

    // 기존에 실수형 타입에 대해 정의되어있던 삼각함수들(sin(), cos(), tan(), sinh(), cosh(), tanh())은 복소수를 인자로 받아들일 수 있도록 확장되었다. 이들 각각은 복소수를 인자로 받아 복소수 값을 반환한다.

    // 초월함수(exp(), log(), log10(), sqrt())들 또한 복소수를 인자로 받아들일 수 있도록 확장되었다. 이들 역시 복소수를 인자로 받아 복소수를 반환한다.

    // 표준 라이브러리에서는 여러가지 형태의 지수함수 pow()을 정의하고 있는데, 밑이 복소수이고 지수가 정수/실수/복소수인 것, 밑이 실수이고 지수가 복소수인 것들이 있다.

    cout << "==============================\n";



    // 예제 : 이차방정식의 근
    // 이차방정식 ax^2 + bx + c = 0의 근을 아래의 방법으로 구할 수 있다.

    cpx a(1.0), b(0.0), c(1.0);
    cpx root = sqrt(b * b - 4.0 * a * c);
    cpx x1 = (-b + root) / (a * 2.0);
    cpx x2 = (-b - root) / (a * 2.0);

    cout << x1 << ' ' << x2 << '\n';

    return 0;
}